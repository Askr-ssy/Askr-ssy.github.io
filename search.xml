<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>a is b ?</title>
      <link href="/2020/03/30/a-is-b/"/>
      <url>/2020/03/30/a-is-b/</url>
      
        <content type="html"><![CDATA[<p>今天在社区 遇到一个蛮有意思的问题,分享出来给大家</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;猜测一下运行结果是否为True</span><br><span class="line">a &#x3D; &quot;some_string&quot;</span><br><span class="line">b &#x3D; &quot;some&quot; + &quot;_&quot; + &quot;string&quot;</span><br><span class="line"></span><br><span class="line">c &#x3D; &quot;hello&quot;</span><br><span class="line">d &#x3D; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">e &#x3D; &quot;hello!&quot;</span><br><span class="line">f &#x3D; &quot;hello!&quot;</span><br><span class="line"></span><br><span class="line">g,h &#x3D; &quot;hello!&quot;,&quot;hello!&quot;</span><br><span class="line"></span><br><span class="line">print(a is b, c is d, e is f,g is h)</span><br></pre></td></tr></table></figure><h2 id="第一次解答"><a href="#第一次解答" class="headerlink" title="第一次解答"></a>第一次解答</h2><p>刚开始,在没有实际运行的情况下,因为考虑到小数据池的原因,猜测答案为 false true true true</p><p>具体解释为</p><p>1.无法确定 解释器否会把表达式求值后在进行引用小数据池中的内容，所以未false</p><p>2.很简单的小数据池 引用 所以为 true</p><p>3.同上</p><p>4.同上</p><hr><h2 id="实际答案"><a href="#实际答案" class="headerlink" title="实际答案"></a>实际答案</h2><p>然而,在Cpython 3.6.9 实际运行后,答案为 True True False True </p><hr><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><p>发现实际答案后，完全能够理解第一个的结果为true,解释器可能会在表达式求值后，进行对左值的赋值或引用，然而3,4结果确十分迷惑,初步猜想是达到小数据池的阈值,可是g,h 的结果所违反,在和其他人讨论后,指向了Cpython的内部实现机制-驻留机制</p><p>通常意义上来说,我们所说的Pyhton,也即Cpython的小数据池,就是由 <strong>驻留机制(intern)</strong> 所实现的,驻留机制对于字符串的隐式驻留,有一道筛选 即 <strong>只有包含ASCII字母，数字或下划线的字符串才会被隐式驻留</strong> 所以,e与f 才会被判定为不相似.在g,h中，也许是Cpython的进一步优化,在同一语句中,只创建了一个对象,然后两个引用. <strong>当然,这并不能说明其发生了隐式驻留.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; &quot;wtf!&quot;, &quot;wtf!&quot;</span><br><span class="line">c &#x3D; &quot;wtf!&quot;</span><br><span class="line">a is b</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">a is c</span><br><span class="line">&gt;&gt;&gt; False</span><br><span class="line">b is c</span><br><span class="line">&gt;&gt;&gt; False</span><br></pre></td></tr></table></figure><p>这里可以看到 c 与 a 或 b 并不相同,并且在进一步尝试下发现,空字符串和单个字符串(包含非法字符)也会被驻留</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &#39;&#39;</span><br><span class="line">b &#x3D; &#39;&#39;</span><br><span class="line">a is b</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">a &#x3D; &#39;_&#39;</span><br><span class="line">b &#x3D; &#39;_&#39;</span><br><span class="line">a is b</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">a &#x3D; &#39;&amp;&#39;</span><br><span class="line">b &#x3D; &#39;&amp;&#39;</span><br><span class="line">a is b</span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure><p>当然,既然有隐式驻留,那么就有显示驻留,翻了一下相关文档后, 使用sys.intern 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; intern(&quot;wtf!&quot;)</span><br><span class="line">b &#x3D; intern(&quot;wtf!&quot;)</span><br><span class="line">a is b</span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 优化文案</li><li><input disabled="" type="checkbox"> 尝试查看Cpython相关文档</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 小数据池 </tag>
            
            <tag> cpython </tag>
            
            <tag> 驻留机制 </tag>
            
            <tag> intern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3_import</title>
      <link href="/2019/03/31/python3-import/"/>
      <url>/2019/03/31/python3-import/</url>
      
        <content type="html"><![CDATA[<h1 id="Python3-Import-之-finder"><a href="#Python3-Import-之-finder" class="headerlink" title="Python3 Import 之 finder"></a>Python3 Import 之 finder</h1><p>&ensp;&ensp;&ensp;&ensp;在Python 中,导入一个模块最常见的方式就是使用 <strong>import</strong> 语句, import 语句本质是对 <strong>__import__</strong> 语句的重写,不过这里并不多说, import 实际上分为两个过程,第一部分是搜索指定名称的模块,然后返回一个说明对象,另一个部分是根据前者返回的说明对象进行加载,这里我们首先说第一部分.</p><h2 id="sys-modules"><a href="#sys-modules" class="headerlink" title="sys.modules"></a>sys.modules</h2><p>&ensp;&ensp;&ensp;&ensp;首先,Python 会对sys.modules 进行搜索, modules 这里起到了缓存之前导入的所有模块的作用. 如果在搜索 sys.modules 中找模块名称关联的值,那么说明其不是第一次导入,其关联的值就是需要导入的模块,导入过程完成.</p><p>&ensp;&ensp;&ensp;&ensp;这里有需要注意的几点</p><ul><li>sys.modules是可写的 删除key 并不会破坏关联的模块(因为其他模块可能会保留对它的引用),但会使模块名的缓存目录失效,导致下次导入时,重新搜索.</li><li>如果 sys.modules 中存在指定的名称，但是关联值却为 <strong>none</strong> 那么会引发 <strong>ModuleNotFoundError。</strong></li></ul><p>&ensp;&ensp;&ensp;&ensp;如果指定名称的模块在 sys.modules 找不到，则将发起调用 Python 的导入协议以查找和加载该模块. 此协议由两个概念性模块构成，即 <strong>查找器</strong> 和 <strong>加载器</strong> .查找器的任务是确定是否能使用其所知的策略找到该名称的模块。 同时实现这两种接口的对象称为 <strong>导入器</strong> 它们在确定能加载所需的模块时会返回其自身。</p><h2 id="sys-meta-path"><a href="#sys-meta-path" class="headerlink" title="sys.meta_path"></a>sys.meta_path</h2><p>&ensp;&ensp;&ensp;&ensp; Python默认包含三个导入器, 第一个知道如何定位内置模块，第二个知道如何定位冻结模块。 第三个默认查找器会在 导入路径中(一般为sys.path) 中搜索模块。 导入路径 是一个由文件系统路径或 zip 文件组成的位置列表。 它还可以扩展为搜索任意可定位资源，例如由 URL 指定的资源。</p><p>PS: 可以在sys.meta_path 看到默认包含的三个导入器</p><p>PS:导入机制是可扩展的，因此可以加入新的查找器以扩展模块搜索的范围和作用域</p><h2 id="find-spec"><a href="#find-spec" class="headerlink" title="find_spec()"></a>find_spec()</h2><p>&ensp;&ensp;&ensp;&ensp; Python 中,如果你在sys.modules中无法找到模块,那么会搜索sys.meta_path ,其中包含 <strong>元路径查找器</strong> 对象列表,查找器必须实现 find_spec() 这一方法，该方法接受三个参数：名称、导入路径和目标模块（可选，元路径查找器可使用任何策略来确定它是否能处理指定名称的模块。</p><p>如果元路径查找器知道如何处理指定名称的模块，返回一个说明对象，不行则返回None,如果 sys.meta_path 处理过程到达结尾，仍未返回说明对象，引发ModuleNotFoundError 并且向上传播，并放弃导入过程。</p><p>find_spec() 方法调用带有两到三个参数。 第一个是被导入模块的完整限定名称，例如 foo.bar.baz。 第二个参数是供模块搜索使用的路径条目。 对于最高层级模块，第二个参数为 None，但对于子模块或子包，第二个参数为父包<strong>path</strong>属性的值。 如果相应的<strong>path</strong>属性无法访问，将引发 ModuleNotFoundError。 第三个参数是一个将被作为稍后加载目标的现有模块对象。 导入系统仅会在重加载期间传入一个目标模块。</p><h2 id="PathFinder"><a href="#PathFinder" class="headerlink" title="PathFinder"></a>PathFinder</h2><p>Python 的默认 sys.meta_path 具有三种元路径查找器</p><ul><li>内置模块导入(BuiltinImporter)</li><li>冻结模块导入(FrozenImporter)</li><li>路径查找导入(PathFinder)</li></ul><p>这里主要说第三种,也即PathFinder,它会搜索包含一个 路径条目 的列表，列表中每个路径代表着一个用于搜索模块的位置</p><p>PathFinder 会有 <strong>sys.path</strong> , <strong>sys.path_hooks</strong> 和 <strong>sys.path_importer_cache</strong> 三个变量供它使用,与此同时，在导入次级包的时候，顶级包的<strong>path</strong>也会被使用,不过经常被使用的是 <strong>sys.path</strong> 和顶级包的<strong>path</strong></p><p><strong>sys.path</strong> 包含一个提供模块和包搜索位置的字符串列表。 它初始化自 PYTHONPATH 环境变量以及多种其他特定安装和实现的默认设置。 sys.path 条目可指定的名称有文件系统中的目录、zip 文件和其他可用于搜索模块的潜在“位置”（参见 site 模块），例如 URL 或数据库查询等。 在 sys.path 中只能出现字符串和字节串；所有其他数据类型都会被忽略。</p><p>在Python 编译运行中,sys.path 会把启动文件的目录放在这个列表中的第一位，<br>与此同时，如果我们想要方便快捷的管理自己的模块，也可以在其中插入自己的路径，以供搜索。</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul><li><input disabled="" type="checkbox"> 重写</li><li><input disabled="" type="checkbox"> 添加子模块导入的内容</li><li><input disabled="" type="checkbox"> 添加图表</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.python.org/3.7/reference/import.html" target="_blank" rel="noopener">https://docs.python.org/3.7/reference/import.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> import </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>secure_shell 简述之非对称加密</title>
      <link href="/2019/02/15/secure-shell-1/"/>
      <url>/2019/02/15/secure-shell-1/</url>
      
        <content type="html"><![CDATA[<h2 id="SSH简述"><a href="#SSH简述" class="headerlink" title="SSH简述"></a>SSH简述</h2><p>&ensp;&ensp;&ensp;&ensp;SSH 全称为Secure Shell , 是一种加密的 <strong>网络传输协议</strong> ,即理论上任何网络服务都可以用SSH来安全传输，不过主要用于远程登陆系统。SSH的出现主要用于取代以往不安全的Telnet 和非安全shell的替代品，Telnet 与 Berkeley Login，rsh，rexec等协议采用明文传输，容易遭受到攻击，所以应此产生了SSH这种能在非安全网络环境下(容易受到攻击，如互联网)信息的加密完整可靠。</p><hr><h2 id="SSH原理"><a href="#SSH原理" class="headerlink" title="SSH原理"></a>SSH原理</h2><p>&ensp;&ensp;&ensp;&ensp;谈到SSH就不得不提到SSH的通信原理 <strong>公开密钥加密(Public-Key Cryptography)</strong> 国内也有叫法叫做 <strong>非对称加密</strong> ，我个人比较喜欢后者,不过在这里为了更好的说明原理就是用学术名称.</p><p>&ensp;&ensp;&ensp;&ensp;公开密钥加密 由两部分组成，一部分是如其名称是一个公共密钥，公钥可以被别人所知，另一个是私有密钥，私钥只能自己知道. 公共密钥加密看似比普通的单密钥加密多了一个公钥,但是这确是 公开密钥加密算法的精髓,保证其能在非安全网络环境下进行安全传输的关键.</p><hr><h2 id="公开密钥加密的原理"><a href="#公开密钥加密的原理" class="headerlink" title="公开密钥加密的原理"></a>公开密钥加密的原理</h2><p>&ensp;&ensp;&ensp;&ensp;简单来说，公开密钥加密的核心是采用基于数学问题的密码算法，产生一个公钥和一个密钥，公钥和密钥加密的消息只能由对应的密钥和公钥解密，其自身也无法解密，这种情况下，可以把公钥放出去，因为只有私钥可以解密，任何对密文的修改都会导致私钥无法解密，所以可以在非安全的网络环境下传输。</p><h3 id="公开密钥加密的数学原理-RSA算法"><a href="#公开密钥加密的数学原理-RSA算法" class="headerlink" title="公开密钥加密的数学原理 (RSA算法)"></a>公开密钥加密的数学原理 (RSA算法)</h3><p>&ensp;&ensp;&ensp;&ensp;这里以RSA算法为版本进行讲解。假设A和B想过通过一个不安全的网络信道进行通信，那么A可以通过以下方式来产生一个公钥和一个密钥</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>随意选择两个大的素数 p和q,p!=q,计算 N=pq</span><br><span class="line"><span class="number">2.</span>根据欧拉函数，r = φ (N) = φ(p)φ(q) = φ(p<span class="number">-1</span>)φ(q<span class="number">-1</span>)</span><br><span class="line"><span class="number">3.</span>选择一个小于r,并且与r互质的整数e,并求e关于r的模逆元，命名为d (求d令ed = <span class="number">1</span> (mod r))</span><br><span class="line"><span class="number">4.</span>将 p 和 q 销毁</span><br><span class="line"><span class="number">5.</span>(N,e)为公钥,(N,d)为私钥</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;如此，B在得知A的公钥(N,e)后，如果想要给A发送一个消息，可以通过提前约定的格式把明文m转化为一个小于N的非负整数n，通过公式 <strong>$c \equiv n^e \pmod{N}$</strong> 来将密文m转化为c，并且将其传输给a</p><p>&ensp;&ensp;&ensp;&ensp;并且，a在得到密文c后通过 <strong>$n \equiv c^d \pmod{N}$</strong> 来解出n,并且通过约定的格式还原出m.</p><p>解码的原理是<br><strong>$c^d \equiv n^{e \cdot d} \pmod{N}$</strong></p><p>已知 <strong>$e \cdot d \equiv 1 \pmod{r}$</strong>,即 <strong>$ed = 1 +h\varphi (n)$</strong>.由 欧拉定理可得：</p><p><strong>$n^{ed}=n^{1+h\varphi(n)}=n \left(n^{\varphi(N)}\right)^{h} \equiv n(1)^h \pmod{N} \equiv n \ \pmod{N}$</strong></p><p>由此，就形成了一次完整的RSA公开密钥加密的加密和解密过程。</p><hr><h2 id="Linux-下的ssh"><a href="#Linux-下的ssh" class="headerlink" title="Linux 下的ssh"></a>Linux 下的ssh</h2><p>&ensp;&ensp;&ensp;&ensp;在Linux 下 SSH 的通常使用方式分为两种。 <strong>一种是自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录，另外一种是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管._</strong></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zh.wikipedia.org/zh-hans/Secure_Shell" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/Secure_Shell</a></p><hr><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 加上参考链接</li><li><input disabled="" type="checkbox"> 加上图片</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> rsa </tag>
            
            <tag> 非对称加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lvalur_and_rvalue</title>
      <link href="/2019/01/22/lvalur-and-rvalue/"/>
      <url>/2019/01/22/lvalur-and-rvalue/</url>
      
        <content type="html"><![CDATA[<h1 id="cpp-的-value-category"><a href="#cpp-的-value-category" class="headerlink" title="cpp 的 value_category"></a>cpp 的 value_category</h1><p>在cpp 当中 每个表达式(带有操作数的操作符，字面值，变量名等)都有一个类型与值类型 。</p><p>值类型是在表达式求值期间创建，复制和移动临时对象时编译器必须遵循的规则的基础，并且只属于三种类型的其中之一：prvalue xvalue lvalue。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 等待补充</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> lvalue </tag>
            
            <tag> rvalue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>copy_and_deepcopy</title>
      <link href="/2018/12/22/copy-and-deepcopy/"/>
      <url>/2018/12/22/copy-and-deepcopy/</url>
      
        <content type="html"><![CDATA[<h2 id="copy-and-deepcopy"><a href="#copy-and-deepcopy" class="headerlink" title="copy and deepcopy"></a>copy and deepcopy</h2><p>在python3 中 复制分为三种,即 “赋值” “浅拷贝” “深拷贝”.python 官方文档解释如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assignment statements in Python do not copy objects, they create bindings between a target and an object. For collections that are mutable or contain mutable items, a copy is sometimes needed so one can change one copy without changing the other. This module provides generic shallow and deep copy operations (explained below).</span><br></pre></td></tr></table></figure><hr><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>赋值即利用 “=” 号运算符进行赋值, 但是这种赋值其本质是 “引用”, 即 重新创建一个变量名,然后绑定到 “=” 号右值的地址,这种情况下,<strong>任何对新创建的变量进行的修改都会同步到旧的变量上!</strong></p><p>案例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; old &#x3D; 2</span><br><span class="line">&gt;&gt;&gt; new &#x3D; old</span><br><span class="line">&gt;&gt;&gt; id(old)</span><br><span class="line">140721449431328</span><br><span class="line">&gt;&gt;&gt; id(new)</span><br><span class="line">140721449431328</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; old &#x3D; [1,2,3]</span><br><span class="line">&gt;&gt;&gt; new &#x3D; old</span><br><span class="line">&gt;&gt;&gt; old[0]&#x3D;&quot;1&quot;</span><br><span class="line">&gt;&gt;&gt; new</span><br><span class="line">[&#39;1&#39;, 2, 3]</span><br><span class="line">&gt;&gt;&gt; old is new</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; id(old)&#x3D;&#x3D;id(new)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>PS:总结来说,则是<strong>创建了一个新的变量名.然后指向旧变量的地址</strong></p><hr><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>第二种即是我们常说的 <strong>浅拷贝</strong> 这种拷贝是在于自定义的数据类型 被 “=” 运算符使用时所发生的.这种情况下 任何简易的修改(指 第一层引用的修改) 并不会改动另一个变量,但是在修改深处的值时,则依旧会影响到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; old &#x3D; [1,2,[3,4]]</span><br><span class="line">&gt;&gt;&gt; new &#x3D; copy.copy(old)</span><br><span class="line">&gt;&gt;&gt; old[0]&#x3D;&quot;1&quot;</span><br><span class="line">&gt;&gt;&gt; old</span><br><span class="line">[&#39;1&#39;, 2, [3, 4]]</span><br><span class="line">&gt;&gt;&gt; new</span><br><span class="line">[1, 2, [3, 4]]</span><br><span class="line">&gt;&gt;&gt; old[2][0] &#x3D; &quot;3&quot;</span><br><span class="line">&gt;&gt;&gt; old</span><br><span class="line">[&#39;1&#39;, 2, [&#39;3&#39;, 4]]</span><br><span class="line">&gt;&gt;&gt; new</span><br><span class="line">[1, 2, [&#39;3&#39;, 4]]</span><br></pre></td></tr></table></figure><p>PS:总结来说,<strong>浅拷贝在复制的时候,对于变量的第一层地址.创建了新的空间.但是对于第二层以下的地址.则是直接偷懒.把地址复制了赋予左边,并没有开创同等的空间</strong></p><hr><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>第三种 深拷贝 才是真正意义上的完全拷贝.即重新创建与右值同样大小的空间.然后循环复制.这种情况下.新创建的变量无论如何修改都不会影响到旧的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; old &#x3D; [1,2,[3,4]]</span><br><span class="line">&gt;&gt;&gt; new &#x3D; copy.deepcopy(old)</span><br><span class="line">&gt;&gt;&gt; new</span><br><span class="line">[1, 2, [3, 4]]</span><br><span class="line">&gt;&gt;&gt; new[0]&#x3D;&quot;1&quot;</span><br><span class="line">&gt;&gt;&gt; new[2][0]&#x3D;&quot;3&quot;</span><br><span class="line">&gt;&gt;&gt; new</span><br><span class="line">[&#39;1&#39;, 2, [&#39;3&#39;, 4]]</span><br><span class="line">&gt;&gt;&gt; old</span><br><span class="line">[1, 2, [3, 4]]</span><br></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><a href="https://docs.python.org/3/library/copy.html" target="_blank" rel="noopener">https://docs.python.org/3/library/copy.html</a></p><h5 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h5><pre><code>[ ] 加上图片</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> python </tag>
            
            <tag> copy </tag>
            
            <tag> deepcopy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpu 命名规则 intel篇</title>
      <link href="/2018/11/12/cpu-naming-rules-intel/"/>
      <url>/2018/11/12/cpu-naming-rules-intel/</url>
      
        <content type="html"><![CDATA[<p>intel cpu 型号众多，大概清理了一下命名规则</p><h2 id="intel-cpu-的产品系列"><a href="#intel-cpu-的产品系列" class="headerlink" title="intel cpu 的产品系列"></a>intel cpu 的产品系列</h2><hr><p>intel 分为 八个序列，分别为</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Core</span><span class="params">(酷睿)</span></span>：主要面向中高端消费者，工作站和发烧级的处理器系列,推出时取代了当时的Pentium(奔腾)处理器的中高端定位，并将Pentium移至入门级系列，也将Celeron(赛扬)处理器推向低端系列。Xeon(至强)处理器用于服务器和工作站市场,但早期命名规则混乱，严格来说不算是连续性的品牌。</span><br><span class="line"> </span><br><span class="line">Pentium：intel 早期推出的唯一处理器序列，后来衍生出低端的 Celeron 和 面向服务器的 Xeon 系列后，intel 又推出了 Core 系列取代 Pentium 系列后，彻底成为了低端处理器序列，市场定位在 Celeron 之上，Core 之下。</span><br><span class="line"></span><br><span class="line">Celeron: 早期由 Pentium 系列衍生出的低端型号~，在 Pentium 被 Core 取代后，市场定位更低了，彻底成为低端型号P</span><br><span class="line"></span><br><span class="line">Xeon：早期由 Pentium 系列衍生出来，主要供服务器及工作站使用，亦有超级计算机采用此处理器，历史悠久~。</span><br><span class="line"></span><br><span class="line">Xeon Phi(至强融核)：首款英特尔集成众核（Many Integrated Core，MIC）架构产品。用作高性能计算（HPC）的超级计算机或服务器的加速卡。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Itanium</span><span class="params">(安腾)</span></span>：是英特尔安腾架构（通常称之为IA-<span class="number">64</span>）的<span class="number">64</span>位处理器，市面上出现较少，近年来也没有消息。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Atom</span><span class="params">(凌动)</span></span>：Intel的一个超低电压处理器系列，和 Itanium 一样，近年比较少见。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Quark</span><span class="params">(夸克)</span></span>：Intel 最近新出的面向物联网的处理器序列，特点是小尺寸和低功耗。</span><br></pre></td></tr></table></figure><p>不过这里因为 Xeon Phi,Itanium,Atom,Quark 过于少见,就以常见的Core 和 Xeon 的命名规则作为讲解。</p><hr><h3 id="Core-命名规则"><a href="#Core-命名规则" class="headerlink" title="Core 命名规则"></a>Core 命名规则</h3><p>举一个例子，一个intel 完整的名称是：</p><center>Intel Core i7 - 7500 U</center><p>分开解析,Core 是品牌， i7 是标识符，标明其在品牌中的定位，7 代表着代数，是第七代处理器，500是 <strong>S</strong> tock <strong>K</strong> eeping <strong>U</strong> nit,类似于图书的ISBN号，用于内部标识，但是根据实际情况，数值越大，性能越强。<br>U 代表着后缀，类似于修饰符的功能，一般有K(可超频)，T(功耗优化)，M(移动处理器)等。</p><p>在一般看到一款CPU型号的时候，一般来说在 标识符(i3,i5,i7)和代数(5th,6th,7th)相同的情况下，SKU越大，性能越强，对于性能比较来说，通常是 标识符&gt;代数&gt;SKU。</p><hr><h3 id="Xeon-命名规则"><a href="#Xeon-命名规则" class="headerlink" title="Xeon 命名规则"></a>Xeon 命名规则</h3><p>Xeon 系列 比较复杂，下面由两个分支，这里先拿标准的至强处理器当作案例</p><center> Intel Xeon E3 - 1230 V3 </center><p>和之前一样，Intel Xeon 是品牌，E3 是生产线区别 ，也是标识符，1 指的是单主板下最大CPU数量，2 指的是 接口类型，30 指的是 SKU ，通常在SKU后面会有一些修饰符，例如 E3-1230L V3 这种，L表示的就是低功耗的修饰符，V3 则代表了这是这款CPU型号的第三代。</p><p>近年新出的 至强可扩展处理器，下面是一个经典的案例：</p><center> Intel Xeon Pltinum 8180 m processor</center><p>一样，Intel Xeon 是品牌，Platium 是其型号定位，8 是 SKU level ,表示性能和级别，可以理解型号定位的细化版本，1 是处理器的代数 80 是SKU，SKU后面有可能会有一到两个修饰符。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://ark.intel.com/content/www/cn/zh/ark.html#@Processors" target="_blank" rel="noopener">https://ark.intel.com/content/www/cn/zh/ark.html#@Processors</a></p><hr><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 加入时间序列</li><li><input disabled="" type="checkbox"> 撰写 amd 篇</li><li><input disabled="" type="checkbox"> 加上图片</li><li><input disabled="" type="checkbox"> 补充其他序列</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> cpu </tag>
            
            <tag> 命名规则 </tag>
            
            <tag> intel </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
