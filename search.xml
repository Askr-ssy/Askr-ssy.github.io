<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IPC-进程间通信</title>
      <link href="/2020/05/20/Inter-Process-Communication-1/"/>
      <url>/2020/05/20/Inter-Process-Communication-1/</url>
      
        <content type="html"><![CDATA[<h1 id="本机-不同进程之间的通讯"><a href="#本机-不同进程之间的通讯" class="headerlink" title="本机 - 不同进程之间的通讯"></a>本机 - 不同进程之间的通讯</h1><p>在计算机科学当中，不同进程都有独立的系统资源，进程与进程之间是相互隔离的。这时，为了让不同的进程互相访问资源并进行协调工作，才有了进程间通信。</p><p>通常，进程间通信分为C/S，使用操作系统提供的以下接口来进行通信，这里大致从传输速率，传输介质，安全性，数据易管理性简单说下。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>在指定的目录利用文件来进行通信，也是一个简单粗暴，但是在架构简单的情况下十分好用的方式，只要处理好读写锁，适用于进程大量读取数据，少量修改的情况，缺点是进程间的通信介质为磁盘，传输速率被限制，而且安全性依靠文件系统，需要自己去在程序中管理文件，不是很方便。</p><h2 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h2><p>信号是 *nix系统和其他兼容POSIX的操作系统中才会使用的，信号是一种通知，它会发送一个指定的信号给进程，如”SIGABRT”,”SIGKILL”,”SIGSTOP”等，操作系统会执行进程的 信号处理程序，如果没有，则执行默认程序。</p><p>信号是由操作系统支持的，所以传输速率很快，但是每次传输的数据量很少，最多不超过 2^6 个,传输介质可以视为cpu,但是如果使用信号作为数据的传输手段，那么安全会有很大的问题，因为信号原本是作为对进程的控制而使用的，贸然使用会破坏原本对进程的控制手段，更有可能在进程变成僵尸进程的时候，没有解决手段。而作为一个对单一进程发送数据的手段来所，基本不需要考虑管理性。</p><h2 id="Socket-NetWork"><a href="#Socket-NetWork" class="headerlink" title="Socket (NetWork)"></a>Socket (NetWork)</h2><p>本质是操作系统为进程提供的面向网络的，一种进程通信手段，通常是指使用IP协议的Socket,用于和网络中其他进程的通信，不过在终端 指向本机的时候也可以和本机中的其他进程通信，传输介质根据网络速率而定，介质是网络，安全性在基于tcp的情况下是可以保证的，管理性算是不错，但是需要自己去进行管理。</p><h2 id="Socket-Unix-domain"><a href="#Socket-Unix-domain" class="headerlink" title="Socket (Unix domain)"></a>Socket (Unix domain)</h2><p>Socket 原本是为网络通讯设计的，但后来在Socket的框架上发展出一种IPC机制，即是 Unix Socket，是操作系统提供的，用于同一台机器上不同进程与不同进程之间的通信，传输速率因为是字节通过内核，速率并不算满，介质可以视为CPU，安全性可以保证，管理性也算不错</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列 更多的情况用于网络传输数据等，利用队列的结构来实现，优点是异步，可以容纳较多的消息等，本机的情况下，传输速率 应该是由实现软件来实现，介质可以使为内存，如果考虑到持久化的情况，可能速度会稍慢，安全性由实现来决定，不过一般成熟的框架的安全性是可以保证的，数据的管理性因为队列的结构，可以说是十分不错</p><h2 id="Pipe-匿名"><a href="#Pipe-匿名" class="headerlink" title="Pipe (匿名)"></a>Pipe (匿名)</h2><p>匿名通道 基本是用于父进程和子进程之间的通信，父进程创建一个通道，fork的时候，把子进程和父进程的通道链接到一起，半工通信，生命周期基于父进程，传输速率很快，介质视为CPU，安全性不错，但是数据的管理性并不是很好</p><h2 id="Pipe-命名"><a href="#Pipe-命名" class="headerlink" title="Pipe (命名)"></a>Pipe (命名)</h2><p>命名通道 是匿名通道的加强版，可以用于任意进程之间的通信，而不像是匿名通道只能用与父进程与子进程的通信，生命周期不被父进程限制，具体由文件系统实现，传输速率不错，传输介质为文件，安全性还可以(？)，管理性还可以。</p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>通常是值 由某个进程，所创建的可以被其他进程所访问的内存区域，具体实现由操作系统来决定，传输速率较快，介质为内存，安全性较高，数据管理性较差。</p><h2 id="Memory-mapped-file"><a href="#Memory-mapped-file" class="headerlink" title="Memory-mapped file"></a>Memory-mapped file</h2><p>等待补完</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul><li><input disabled="" type="checkbox"> 补完Memory-mapped file</li><li><input disabled="" type="checkbox"> 严格给出传输速率，安全性，管理性的定义</li><li><input disabled="" type="checkbox"> 严格确定各种通信手段的介质</li><li><input disabled="" type="checkbox"> 画出图表</li><li><input disabled="" type="checkbox"> 重新真理语言</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IPC </tag>
            
            <tag> socket </tag>
            
            <tag> pipe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unicode_and_Utf-8</title>
      <link href="/2020/04/17/Unicode-and-Utf-8/"/>
      <url>/2020/04/17/Unicode-and-Utf-8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[翻译]Docker镜像:第一部分-减少镜像大小</title>
      <link href="/2020/04/03/docker-images-part1-reducing-image-size/"/>
      <url>/2020/04/03/docker-images-part1-reducing-image-size/</url>
      
        <content type="html"><![CDATA[<p>该文为翻译文章,因文章写的太好,见猎心喜,未拿到原作者授权,侵删.</p><p><a href="https://www.ardanlabs.com/blog/2020/02/docker-images-part1-reducing-image-size.html" target="_blank" rel="noopener">原文链接</a></p><p>以下为正文</p><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在刚开始使用容器的时候,很容易被我们所生成的镜像大小震惊.我们将回顾许多在不缩减开发人员和维护人员的便捷性的情况下,同时缩减镜像尺寸的技术.在第一部分中,我们将讨论多阶段构建,因为任何想要缩减镜像大小的人都需要从这开始.我们还将说明静态链接和动态链接之间的区别,以及为什么我们要关心它.同时,这也是介绍Alpine<a href="[这里是校注](https://wiki.alpinelinux.org/wiki/Docker)">^1</a>的机会.</p><p>在第二部分,我们将看到与各种流行语言有关的一些特殊性.我们将讨论 GO,以及Java,Node,Python,Ruby,Rust.我们还将讨论有关Alpine的更多信息,以及如何全面利用Alpine.</p><p>在第三部分中,我们将介绍一些与大多数语言和框架相关的 Pattern ( and anti-patterns! ),例如使用通用基础镜像,分离二进制文件并减小大小.我们将总结一些更奇特的或高级的方法,例如 Bazel,Distroless,DockerSlim或UPX . 我们将看到其中的一些方法在某些情况下会适得其反,但在某些特定情况下可能会有用.</p><p>请注意,示例代码以及此处提到的所有Dockerfile,都可以在公共GitHub存储库中方便地获得,并带有一个Compose文件来构建所有镜像并轻松比较它们的大小.</p><h3 id="我们正在尝试解决的问题"><a href="#我们正在尝试解决的问题" class="headerlink" title="我们正在尝试解决的问题"></a>我们正在尝试解决的问题</h3><p>我敢打赌,每个构建了第一个Docker镜像并编译了一些代码的人都对该镜像的大小感到惊讶.</p><p>看看用C编写的这个繁琐的 “hello world” 程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello.c */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用下面这个Dockerfile构建它：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> gcc</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hello.c .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> gcc -o hello hello.c</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./hello"</span>]</span></span><br></pre></td></tr></table></figure><p>但是生成的镜像将超过1 GB,因为它包含着整个gcc镜像！</p><p>如果我们使用Ubuntu镜像,安装一个C编译器,然后编译程序,我们将得到300 MB镜像；看起来更棒,但对于本身小于20 kB的二进制文件而言,仍然太多了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l hello</span></span><br><span class="line">-rwxr-xr-x   1 root root 16384 Nov 18 14:36 hello</span><br></pre></td></tr></table></figure><p>一个同等效果的Go程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello, world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用该golang镜像构建此代码,即使hello程序只有2 MB ,生成的镜像仍为800 MB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l hello</span></span><br><span class="line">-rwxr-xr-x 1 root root 2008801 Jan 15 16:41 hello</span><br></pre></td></tr></table></figure><p>一定有更好的方法！</p><p>让我们看看如何大幅减少这些镜像的大小.在某些情况下,我们将实现99.8％的尺寸减小(但是我们会发现,跨度这么大并不总是一个好主意).</p><p>专业提示：为了轻松比较镜像的大小,我们将使用相同的镜像名称,但使用不同的标签.举例来说,我们的形象会hello:gcc,hello:ubuntu,hello:thisweirdtrick等这样的话,这样我们可以运行docker images hello,它会列出所有的标签为hello镜像,与它们的大小,而不会受到Docker引擎上成千上万的其他镜像的困扰.</p><h3 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h3><p>这是减小镜像尺寸的第一步(也是最激烈的一步).这里我们需要小心,因为如果处理不正确,可能会导致镜像出现问题(甚至可能完全损坏).</p><p>多阶段构建来自一个简单的想法：“我不需要在最终的应用程序镜像中包括C或Go编译器以及整个构建工具链.我只想运送二进制文件！”</p><p>我们通过FROM在Dockerfile中添加另一行来获得多阶段构建.看下面的例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> gcc AS mybuildstage</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hello.c .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> gcc -o hello hello.c</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=mybuildstage hello .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./hello"</span>]</span></span><br></pre></td></tr></table></figure><p>我们使用gcc镜像来构建hello.c程序.然后,我们使用该ubuntu镜像开始一个新阶段(我们称为“运行阶段”).我们的hello从上一阶段复制二进制文件.最终镜像为64 MB,而不是1.1 GB,因此大小减少了约95％：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images minimage</span><br><span class="line">REPOSITORY          TAG                    ...         SIZE</span><br><span class="line">minimage            hello-c.gcc            ...         1.14GB</span><br><span class="line">minimage            hello-c.gcc.ubuntu     ...         64.2MB</span><br></pre></td></tr></table></figure><p>还不错吧？我们可以做得更好.但是首先,需要注意一些技巧和警告.</p><p>在声明构建阶段时,您不必使用AS关键字.从上一个阶段复制文件时,您只需指明该构建阶段的编号(从零开始).</p><p>换句话说,以下两行是相同的：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=mybuildstage hello .</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=0 hello .</span></span><br></pre></td></tr></table></figure><p>就个人而言,我认为在较短的Dockerfile(例如,不超过10行)的构建阶段中使用数字是很好的,但是,只要您的Dockerfile变长(并且可能更复杂,具有多个构建阶段),命名是一个好主意.明确的阶段.这将有助于您的团队成员的维护(以及将来您将在几个月后复习该Dockerfile的将来).</p><h4 id="警告：使用经典镜像"><a href="#警告：使用经典镜像" class="headerlink" title="警告：使用经典镜像"></a>警告：使用经典镜像</h4><p>我强烈建议您在“运行”阶段坚持使用经典镜像.我所说的“经典”是指CentOS,Debian,Fedora,Ubuntu;以及其他熟悉的东西.您可能听说过Alpine,并很想使用它.暂时不要这么做！至少还没有到使用它们的时候.稍后我们将讨论Alpine,并解释为什么我们需要谨慎使用Alpine.</p><h4 id="警告：COPY-–from使用绝对路径"><a href="#警告：COPY-–from使用绝对路径" class="headerlink" title="警告：COPY –from使用绝对路径"></a>警告：COPY –from使用绝对路径</h4><p>从上一阶段复制文件时,路径被解释为相对于上一阶段的根目录.</p><p>在我们使用带有WORKDIR的生成器镜像(例如golang镜像)后,问题就会出现.</p><p>例如我们尝试构建此Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hello.go .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go build hello.go</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=0 hello .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./hello"</span>]</span></span><br></pre></td></tr></table></figure><p>我们收到与以下错误类似的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY failed: stat &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;1be...868&#x2F;merged&#x2F;hello: no such file or directory</span><br></pre></td></tr></table></figure><p>这是因为COPY命令尝试复制 /hello,但是由于WORKDIR 在 golang是/go,所以程序路径实际上是/go/hello.</p><p>如果我们在构建中使用的是正式(或非常稳定)的镜像,通过指定完整的绝对路径,使得我们不必理会它.</p><p>但是,如果将来我们的构建或运行可能会改变这个镜像,那么我建议WORKDIR在构建镜像中指定一个.这将确保文件出现在期望的位置,即使我们用于构建阶段的基本镜像以后也会更改.</p><p>遵循这一原则,用于构建Go程序的Dockerfile如下所示：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /src</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hello.go .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go build hello.go</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=0 /src/hello .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./hello"</span>]</span></span><br></pre></td></tr></table></figure><p>如果您想知道Golang多阶段构建的效果,OK,它们让我们从800 MB的镜像下降到66 MB的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images minimage</span><br><span class="line">REPOSITORY     TAG                              ...    SIZE</span><br><span class="line">minimage       hello-go.golang                  ...    805MB</span><br><span class="line">minimage       hello-go.golang.ubuntu-workdir   ...    66.2MB</span><br></pre></td></tr></table></figure><h3 id="使用-FROM-scratch"><a href="#使用-FROM-scratch" class="headerlink" title="使用 FROM scratch"></a>使用 FROM scratch</h3><p>回到我们的“ Hello World”程序.C版本为16 kB,Go版本为2 MB.我们可以得到这么大的镜像吗？</p><p>我们可以仅使用二进制文件而不用其他文件来构建镜像吗？</p><p>是的! 我们要做的就是使用多阶段构建,然后选择scratch运行镜像.scratch是虚拟镜像.您不能拉或运行它,因为它完全是空的.这就是为什么Dockerfile 如果以 FROM scratch 开始,则意味着我们是从零开始构建的,因为没有使用任何预先存在的东西.</p><p>这为我们提供了以下Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hello.go .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go build hello.go</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=0 /go/hello .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"./hello"</span>]</span></span><br></pre></td></tr></table></figure><p>如果我们构建该镜像,则其大小恰好是二进制文件的大小(2 MB),并且可以正常工作！</p><p>但是,当scratch用作基础时,需要记住一些注意事项.</p><h4 id="没有-shell"><a href="#没有-shell" class="headerlink" title="没有 shell"></a>没有 shell</h4><p>该scratch镜像没有 shell.这意味着我们不能将字符串语法与CMD(或RUN)一起使用.考虑以下Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=0 /go/hello .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> ./hello</span></span><br></pre></td></tr></table></figure><p>如果尝试docker run生成结果镜像,则会收到以下错误消息：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span>: Error response from <span class="attribute">daemon</span>: OCI runtime create <span class="attribute">failed</span>: container_linux.<span class="attribute">go</span>:<span class="number">345</span>: starting container process caused <span class="string">"exec: \"</span>/bin/sh\<span class="string">": stat /bin/sh: no such file or directory"</span>: unknown.</span><br></pre></td></tr></table></figure><p>它的显示结果不是很清楚,但是核心信息在这里：/bin/sh is missing from the image.</p><p>发生这种情况是因为当我们将字符串语法与CMD或RUN一起使用时,参数将传递给/bin/sh.这意味着我们CMD ./hello上面会执行/bin/sh -c “./hello”,因为我们没有/bin/sh 在scratch镜像,这将导致失败.</p><p>解决方法很简单：在Dockerfile中使用JSON语法.CMD ./hello 换成 CMD [“./hello”].当Docker检测到JSON语法时,它将直接运行参数,而无需使用shell.</p><h4 id="没有调试工具"><a href="#没有调试工具" class="headerlink" title="没有调试工具"></a>没有调试工具</h4><p>根据scratch定义,该镜像为空；因此它没有任何帮助我们解决容器问题的方法.没有 shell (正如我们在上一段说的)也没什么ls,ps,ping,等等等等.这意味着我们将无法输入容器(使用docker exec或kubectl exec进行查看).</p><p>(请注意,严格来说,有一些方法可以对我们的容器进行故障排除.我们可以用来docker cp将文件从容器中取出；我们可以docker run –net container:用来与网络堆栈进行交互；像这样的低级工具nsenter可能非常强大. Kubernetes的版本具有短暂容器的概念,但是它仍然处于alpha状态.请记住,所有这些技术肯定会使我们的生活变得更加复杂,尤其是当我们有很多事情要做的时候！)</p><p>这里的一个解决办法是使用 像busybox或alpine 这种镜像代替scratch.当然,它们更大(分别为1.2 MB和5.5 MB),但是在庞大的方案中,如果将其与原始镜像的数百兆字节或千兆字节进行比较起来,付出的代价很小.</p><h4 id="没有libc"><a href="#没有libc" class="headerlink" title="没有libc"></a>没有libc</h4><p>这是一个很难解决的问题.我们在Go中使用简单的“ hello world”可以很好地工作,但是,如果我们尝试在scratch镜像中放置C程序,或者在更复杂的Go程序中(例如,使用网络封装的任何东西),则会收到以下错误消息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">standard_init_linux.go:211: exec<span class="built_in"> user </span>process caused <span class="string">"no such file or directory"</span></span><br></pre></td></tr></table></figure><p>某些文件似乎丢失了.但这并不能告诉我们确切缺少哪个文件.</p><p>丢失的文件是运行我们的程序所必需的动态库.</p><p>什么是动态库,为什么我们需要它？</p><p>程序编译后,将与所使用的库链接.(很简单,我们的“ hello world”程序仍在使用库；这就是puts函数的来源.)很久以前(90年代之前),我们主要使用静态链接,这意味着a所使用的所有库程序将包含在二进制文件中.当从软盘或盒式磁带执行软件时,或者根本没有标准库时,这是完美的选择.但是,在Linux等分时系统上,我们运行许多并发程序,这些程序存储在硬盘上.这些程序几乎总是使用标准的C库.</p><p>在这种情况下,使用动态链接会更加有利.使用动态链接,最终的二进制文件不包含它使用的所有库的代码.相反,它包含这些库的引用,如“这个程序需要的功能 cos 和 sin 和 tan 在 libtrigonometry.so.执行程序时,系统会查找libtrigonometry.so该程序并将其加载到程序旁边,以便程序可以调用这些函数.</p><p>动态链接具有多个优点.</p><p>它节省了磁盘空间,因为不再需要复制通用库.<br>因为这些库可以从磁盘加载一次,然后使用它们在多个程序之间共享,所以可以节省内存.<br>这使维护更加容易,因为在更新库时,我们不需要使用该库重新编译所有程序.<br>(如果我们想更透彻一点,内存节省不是动态库的结果,而是共享库的结果.也就是说,两者通常是并存的.您知道吗,在Linux上,动态库文件通常具有扩展名.so,代表共享库吗？在Windows上是.DLL,它代表动态链接库.)</p><p>回到我们的故事：默认情况下,C程序是动态链接的.使用某些软件包的Go程序也是如此.我们的特定程序使用标准的C库,该库在最新的Linux系统上在文件中libc.so.6中.因此,要运行,我们的程序需要将该文件显示在容器镜像中.而且,如果我们使用scratch,则显然没有该文件.如果我们使用busybox或alpine,则是相同的,因为busybox它不包含标准库,并且alpine正在使用另一个不兼容的库.稍后我们将详细介绍.</p><p>我们该如何解决？至少有3个选项.</p><h4 id="构建静态库"><a href="#构建静态库" class="headerlink" title="构建静态库"></a>构建静态库</h4><p>我们可以告诉我们的工具链制作一个静态二进制文件.有多种方法可以实现该目标(首先要取决于我们如何构建程序),但是如果使用gcc,我们要做的就是添加-static到命令行中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c -static</span><br></pre></td></tr></table></figure><p>现在生成的二进制文件是760 kB(在我的系统上),而不是16 kB.当然,我们将库嵌入二进制文件中,因此更大.但是该二进制文件现在将在scratch镜像中正确运行.</p><p>如果使用Alpine构建静态二进制文件,则可以得到更小的镜像.结果小于100 kB！</p><h4 id="将库添加到我们的镜像"><a href="#将库添加到我们的镜像" class="headerlink" title="将库添加到我们的镜像"></a>将库添加到我们的镜像</h4><p>我们可以使用该ldd工具找出程序需要的库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldd hello</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffdf8acb000)</span><br><span class="line">libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007ff897ef6000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007ff8980f7000)</span><br></pre></td></tr></table></figure><p>我们可以看到程序所需的库,以及系统找到它们的确切路径.</p><p>在上面的示例中,唯一的“真实”库是libc.so.6.linux-vdso.so.1与一种称为VDSO(虚拟动态共享对象)的机制有关,该机制可以加速某些系统调用.让我们假装它不在那里.至于ld-linux-x86-64.so.2,它实际上是动态链接器本身.(从技术上讲,我们的hello二进制文件包含以下信息：“嘿,这是一个动态程序,并且知道如何将其所有部分放在一起的东西是ld-linux-x86-64.so.2”.)</p><p>如果我们愿意,可以将上面列出的所有文件手动添加ldd到镜像中.这将是相当繁琐且难以维护的,尤其是对于程序将有很多依赖性的情况.对于我们的 hello word 程序,这将正常的工作.但是对于更复杂的程序,例如使用DNS的程序,我们会遇到另一个问题.GNU C库(在大多数Linux系统上使用)通过称为名称服务开关(简称为NSS )的相当复杂的机制实现DNS(以及其他一些功能).该机制需要一个配置文件/etc/nsswitch.conf和其他库.但是这些库没有显示ldd,因为它们会在程序运行时稍后加载.如果我们希望DNS解析正常工作,我们仍然需要包括它们！(这些库通常位于/lib64/libnss_*.)</p><p>我个人不建议这样做,因为它非常神秘,难以维护,并且将来很可能会中断.</p><h4 id="使用-busybox-glibc"><a href="#使用-busybox-glibc" class="headerlink" title="使用 busybox:glibc"></a>使用 busybox:glibc</h4><p>有专门为解决所有这些问题而设计的镜像：busybox:glibc.这是一个小镜像(5 MB),使用busybox(因此提供了许多用于故障排除和操作的有用工具)并提供了GNU C库(或glibc).该镜像恰好包含我们前面提到的所有这些讨厌的文件.如果要在小的镜像中运行动态二进制文件,则应使用此方法.</p><p>但是请记住,如果我们的程序使用其他库,则也需要复制这些库.</p><h3 id="总结和-部分-结论"><a href="#总结和-部分-结论" class="headerlink" title="总结和(部分)结论"></a>总结和(部分)结论</h3><p>让我们看看我们如何在C. Spoiler警报中为“ hello world”程序做些事情：此列表包括通过使用Alpine所获得的结果,这将在本系列的下一部分中进行描述.</p><p>原始镜像内置gcc：1.14 GB<br>多级构建与gcc和ubuntu：64.2 MB<br>静态glibc二进制文件alpine：6.5 MB<br>动态二进制文件alpine：5.6 MB<br>静态二进制输入scratch：940 kB<br>静态musl二进制in scratch：94 kB</p><p>大小减少了12000倍,或磁盘空间减少了99.99％.</p><p>不错.</p><p>就个人而言,我不会选择 使用scratch这些镜像(因为对它们进行故障排除可能会很麻烦),但是,如果您要这样做,他们就会在这里为您服务！</p><p>在下一部分中,我们将介绍Go语言特定的一些方面,包括cgo和标签.我们还将介绍其他流行语言,并且我们将讨论更多有关Alpine的信息,非常欢迎您与我一起讨论</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>a is b ?</title>
      <link href="/2020/03/30/a-is-b/"/>
      <url>/2020/03/30/a-is-b/</url>
      
        <content type="html"><![CDATA[<p>今天在社区 遇到一个蛮有意思的问题,分享出来给大家</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;猜测一下运行结果是否为True</span><br><span class="line">a &#x3D; &quot;some_string&quot;</span><br><span class="line">b &#x3D; &quot;some&quot; + &quot;_&quot; + &quot;string&quot;</span><br><span class="line"></span><br><span class="line">c &#x3D; &quot;hello&quot;</span><br><span class="line">d &#x3D; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">e &#x3D; &quot;hello!&quot;</span><br><span class="line">f &#x3D; &quot;hello!&quot;</span><br><span class="line"></span><br><span class="line">g,h &#x3D; &quot;hello!&quot;,&quot;hello!&quot;</span><br><span class="line"></span><br><span class="line">print(a is b, c is d, e is f,g is h)</span><br></pre></td></tr></table></figure><h2 id="第一次解答"><a href="#第一次解答" class="headerlink" title="第一次解答"></a>第一次解答</h2><p>刚开始,在没有实际运行的情况下,因为考虑到小数据池的原因,猜测答案为 false true true true</p><p>具体解释为</p><p>1.无法确定 解释器否会把表达式求值后在进行引用小数据池中的内容，所以未false</p><p>2.很简单的小数据池 引用 所以为 true</p><p>3.同上</p><p>4.同上</p><hr><h2 id="实际答案"><a href="#实际答案" class="headerlink" title="实际答案"></a>实际答案</h2><p>然而,在Cpython 3.6.9 实际运行后,答案为 True True False True </p><hr><h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><p>发现实际答案后，完全能够理解第一个的结果为true,解释器可能会在表达式求值后，进行对左值的赋值或引用，然而3,4结果确十分迷惑,初步猜想是达到小数据池的阈值,可是g,h 的结果所违反,在和其他人讨论后,指向了Cpython的内部实现机制-驻留机制</p><p>通常意义上来说,我们所说的Pyhton,也即Cpython的小数据池,就是由 <strong>驻留机制(intern)</strong> 所实现的,驻留机制对于字符串的隐式驻留,有一道筛选 即 <strong>只有包含ASCII字母，数字或下划线的字符串才会被隐式驻留</strong> 所以,e与f 才会被判定为不相似.在g,h中，也许是Cpython的进一步优化,在同一语句中,只创建了一个对象,然后两个引用. <strong>当然,这并不能说明其发生了隐式驻留.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; &quot;wtf!&quot;, &quot;wtf!&quot;</span><br><span class="line">c &#x3D; &quot;wtf!&quot;</span><br><span class="line">a is b</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">a is c</span><br><span class="line">&gt;&gt;&gt; False</span><br><span class="line">b is c</span><br><span class="line">&gt;&gt;&gt; False</span><br></pre></td></tr></table></figure><p>这里可以看到 c 与 a 或 b 并不相同,并且在进一步尝试下发现,空字符串和单个字符串(包含非法字符)也会被驻留</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &#39;&#39;</span><br><span class="line">b &#x3D; &#39;&#39;</span><br><span class="line">a is b</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">a &#x3D; &#39;_&#39;</span><br><span class="line">b &#x3D; &#39;_&#39;</span><br><span class="line">a is b</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">a &#x3D; &#39;&amp;&#39;</span><br><span class="line">b &#x3D; &#39;&amp;&#39;</span><br><span class="line">a is b</span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure><p>当然,既然有隐式驻留,那么就有显示驻留,翻了一下相关文档后, 使用sys.intern 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; intern(&quot;wtf!&quot;)</span><br><span class="line">b &#x3D; intern(&quot;wtf!&quot;)</span><br><span class="line">a is b</span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 优化文案</li><li><input disabled="" type="checkbox"> 尝试查看Cpython相关文档</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> 小数据池 </tag>
            
            <tag> cpython </tag>
            
            <tag> 驻留机制 </tag>
            
            <tag> intern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3_import</title>
      <link href="/2019/03/31/python3-import/"/>
      <url>/2019/03/31/python3-import/</url>
      
        <content type="html"><![CDATA[<h1 id="Python3-Import-之-finder"><a href="#Python3-Import-之-finder" class="headerlink" title="Python3 Import 之 finder"></a>Python3 Import 之 finder</h1><p>&ensp;&ensp;&ensp;&ensp;在Python 中,导入一个模块最常见的方式就是使用 <strong>import</strong> 语句, import 语句本质是对 <strong>__import__</strong> 语句的重写,不过这里并不多说, import 实际上分为两个过程,第一部分是搜索指定名称的模块,然后返回一个说明对象,另一个部分是根据前者返回的说明对象进行加载,这里我们首先说第一部分.</p><h2 id="sys-modules"><a href="#sys-modules" class="headerlink" title="sys.modules"></a>sys.modules</h2><p>&ensp;&ensp;&ensp;&ensp;首先,Python 会对sys.modules 进行搜索, modules 这里起到了缓存之前导入的所有模块的作用. 如果在搜索 sys.modules 中找模块名称关联的值,那么说明其不是第一次导入,其关联的值就是需要导入的模块,导入过程完成.</p><p>&ensp;&ensp;&ensp;&ensp;这里有需要注意的几点</p><ul><li>sys.modules是可写的 删除key 并不会破坏关联的模块(因为其他模块可能会保留对它的引用),但会使模块名的缓存目录失效,导致下次导入时,重新搜索.</li><li>如果 sys.modules 中存在指定的名称，但是关联值却为 <strong>none</strong> 那么会引发 <strong>ModuleNotFoundError。</strong></li></ul><p>&ensp;&ensp;&ensp;&ensp;如果指定名称的模块在 sys.modules 找不到，则将发起调用 Python 的导入协议以查找和加载该模块. 此协议由两个概念性模块构成，即 <strong>查找器</strong> 和 <strong>加载器</strong> .查找器的任务是确定是否能使用其所知的策略找到该名称的模块。 同时实现这两种接口的对象称为 <strong>导入器</strong> 它们在确定能加载所需的模块时会返回其自身。</p><h2 id="sys-meta-path"><a href="#sys-meta-path" class="headerlink" title="sys.meta_path"></a>sys.meta_path</h2><p>&ensp;&ensp;&ensp;&ensp; Python默认包含三个导入器, 第一个知道如何定位内置模块，第二个知道如何定位冻结模块。 第三个默认查找器会在 导入路径中(一般为sys.path) 中搜索模块。 导入路径 是一个由文件系统路径或 zip 文件组成的位置列表。 它还可以扩展为搜索任意可定位资源，例如由 URL 指定的资源。</p><p>PS: 可以在sys.meta_path 看到默认包含的三个导入器</p><p>PS:导入机制是可扩展的，因此可以加入新的查找器以扩展模块搜索的范围和作用域</p><h2 id="find-spec"><a href="#find-spec" class="headerlink" title="find_spec()"></a>find_spec()</h2><p>&ensp;&ensp;&ensp;&ensp; Python 中,如果你在sys.modules中无法找到模块,那么会搜索sys.meta_path ,其中包含 <strong>元路径查找器</strong> 对象列表,查找器必须实现 find_spec() 这一方法，该方法接受三个参数：名称、导入路径和目标模块（可选，元路径查找器可使用任何策略来确定它是否能处理指定名称的模块。</p><p>如果元路径查找器知道如何处理指定名称的模块，返回一个说明对象，不行则返回None,如果 sys.meta_path 处理过程到达结尾，仍未返回说明对象，引发ModuleNotFoundError 并且向上传播，并放弃导入过程。</p><p>find_spec() 方法调用带有两到三个参数。 第一个是被导入模块的完整限定名称，例如 foo.bar.baz。 第二个参数是供模块搜索使用的路径条目。 对于最高层级模块，第二个参数为 None，但对于子模块或子包，第二个参数为父包<strong>path</strong>属性的值。 如果相应的<strong>path</strong>属性无法访问，将引发 ModuleNotFoundError。 第三个参数是一个将被作为稍后加载目标的现有模块对象。 导入系统仅会在重加载期间传入一个目标模块。</p><h2 id="PathFinder"><a href="#PathFinder" class="headerlink" title="PathFinder"></a>PathFinder</h2><p>Python 的默认 sys.meta_path 具有三种元路径查找器</p><ul><li>内置模块导入(BuiltinImporter)</li><li>冻结模块导入(FrozenImporter)</li><li>路径查找导入(PathFinder)</li></ul><p>这里主要说第三种,也即PathFinder,它会搜索包含一个 路径条目 的列表，列表中每个路径代表着一个用于搜索模块的位置</p><p>PathFinder 会有 <strong>sys.path</strong> , <strong>sys.path_hooks</strong> 和 <strong>sys.path_importer_cache</strong> 三个变量供它使用,与此同时，在导入次级包的时候，顶级包的<strong>path</strong>也会被使用,不过经常被使用的是 <strong>sys.path</strong> 和顶级包的<strong>path</strong></p><p><strong>sys.path</strong> 包含一个提供模块和包搜索位置的字符串列表。 它初始化自 PYTHONPATH 环境变量以及多种其他特定安装和实现的默认设置。 sys.path 条目可指定的名称有文件系统中的目录、zip 文件和其他可用于搜索模块的潜在“位置”（参见 site 模块），例如 URL 或数据库查询等。 在 sys.path 中只能出现字符串和字节串；所有其他数据类型都会被忽略。</p><p>在Python 编译运行中,sys.path 会把启动文件的目录放在这个列表中的第一位，<br>与此同时，如果我们想要方便快捷的管理自己的模块，也可以在其中插入自己的路径，以供搜索。</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul><li><input disabled="" type="checkbox"> 重写</li><li><input disabled="" type="checkbox"> 添加子模块导入的内容</li><li><input disabled="" type="checkbox"> 添加图表</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.python.org/3.7/reference/import.html" target="_blank" rel="noopener">https://docs.python.org/3.7/reference/import.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> import </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>secure_shell 简述之非对称加密</title>
      <link href="/2019/02/15/secure-shell-1/"/>
      <url>/2019/02/15/secure-shell-1/</url>
      
        <content type="html"><![CDATA[<h2 id="SSH简述"><a href="#SSH简述" class="headerlink" title="SSH简述"></a>SSH简述</h2><p>&ensp;&ensp;&ensp;&ensp;SSH 全称为Secure Shell , 是一种加密的 <strong>网络传输协议</strong> ,即理论上任何网络服务都可以用SSH来安全传输，不过主要用于远程登陆系统。SSH的出现主要用于取代以往不安全的Telnet 和非安全shell的替代品，Telnet 与 Berkeley Login，rsh，rexec等协议采用明文传输，容易遭受到攻击，所以应此产生了SSH这种能在非安全网络环境下(容易受到攻击，如互联网)信息的加密完整可靠。</p><hr><h2 id="SSH原理"><a href="#SSH原理" class="headerlink" title="SSH原理"></a>SSH原理</h2><p>&ensp;&ensp;&ensp;&ensp;谈到SSH就不得不提到SSH的通信原理 <strong>公开密钥加密(Public-Key Cryptography)</strong> 国内也有叫法叫做 <strong>非对称加密</strong> ，我个人比较喜欢后者,不过在这里为了更好的说明原理就是用学术名称.</p><p>&ensp;&ensp;&ensp;&ensp;公开密钥加密 由两部分组成，一部分是如其名称是一个公共密钥，公钥可以被别人所知，另一个是私有密钥，私钥只能自己知道. 公共密钥加密看似比普通的单密钥加密多了一个公钥,但是这确是 公开密钥加密算法的精髓,保证其能在非安全网络环境下进行安全传输的关键.</p><hr><h2 id="公开密钥加密的原理"><a href="#公开密钥加密的原理" class="headerlink" title="公开密钥加密的原理"></a>公开密钥加密的原理</h2><p>&ensp;&ensp;&ensp;&ensp;简单来说，公开密钥加密的核心是采用基于数学问题的密码算法，产生一个公钥和一个密钥，公钥和密钥加密的消息只能由对应的密钥和公钥解密，其自身也无法解密，这种情况下，可以把公钥放出去，因为只有私钥可以解密，任何对密文的修改都会导致私钥无法解密，所以可以在非安全的网络环境下传输。</p><h3 id="公开密钥加密的数学原理-RSA算法"><a href="#公开密钥加密的数学原理-RSA算法" class="headerlink" title="公开密钥加密的数学原理 (RSA算法)"></a>公开密钥加密的数学原理 (RSA算法)</h3><p>&ensp;&ensp;&ensp;&ensp;这里以RSA算法为版本进行讲解。假设A和B想过通过一个不安全的网络信道进行通信，那么A可以通过以下方式来产生一个公钥和一个密钥</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>随意选择两个大的素数 p和q,p!=q,计算 N=pq</span><br><span class="line"><span class="number">2.</span>根据欧拉函数，r = φ (N) = φ(p)φ(q) = φ(p<span class="number">-1</span>)φ(q<span class="number">-1</span>)</span><br><span class="line"><span class="number">3.</span>选择一个小于r,并且与r互质的整数e,并求e关于r的模逆元，命名为d (求d令ed = <span class="number">1</span> (mod r))</span><br><span class="line"><span class="number">4.</span>将 p 和 q 销毁</span><br><span class="line"><span class="number">5.</span>(N,e)为公钥,(N,d)为私钥</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;如此，B在得知A的公钥(N,e)后，如果想要给A发送一个消息，可以通过提前约定的格式把明文m转化为一个小于N的非负整数n，通过公式 <strong>$c \equiv n^e \pmod{N}$</strong> 来将密文m转化为c，并且将其传输给a</p><p>&ensp;&ensp;&ensp;&ensp;并且，a在得到密文c后通过 <strong>$n \equiv c^d \pmod{N}$</strong> 来解出n,并且通过约定的格式还原出m.</p><p>解码的原理是<br><strong>$c^d \equiv n^{e \cdot d} \pmod{N}$</strong></p><p>已知 <strong>$e \cdot d \equiv 1 \pmod{r}$</strong>,即 <strong>$ed = 1 +h\varphi (n)$</strong>.由 欧拉定理可得：</p><p><strong>$n^{ed}=n^{1+h\varphi(n)}=n \left(n^{\varphi(N)}\right)^{h} \equiv n(1)^h \pmod{N} \equiv n \ \pmod{N}$</strong></p><p>由此，就形成了一次完整的RSA公开密钥加密的加密和解密过程。</p><hr><h2 id="Linux-下的ssh"><a href="#Linux-下的ssh" class="headerlink" title="Linux 下的ssh"></a>Linux 下的ssh</h2><p>&ensp;&ensp;&ensp;&ensp;在Linux 下 SSH 的通常使用方式分为两种。 <strong>一种是自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录，另外一种是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管._</strong></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zh.wikipedia.org/zh-hans/Secure_Shell" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/Secure_Shell</a></p><hr><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 加上参考链接</li><li><input disabled="" type="checkbox"> 加上图片</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> rsa </tag>
            
            <tag> 非对称加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lvalur_and_rvalue</title>
      <link href="/2019/01/22/lvalur-and-rvalue/"/>
      <url>/2019/01/22/lvalur-and-rvalue/</url>
      
        <content type="html"><![CDATA[<h1 id="cpp-的-value-category"><a href="#cpp-的-value-category" class="headerlink" title="cpp 的 value_category"></a>cpp 的 value_category</h1><p>在cpp 当中 每个表达式(带有操作数的操作符，字面值，变量名等)都有一个类型与值类型 。</p><p>值类型是在表达式求值期间创建，复制和移动临时对象时编译器必须遵循的规则的基础，并且只属于三种类型的其中之一：prvalue xvalue lvalue。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 等待补充</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> lvalue </tag>
            
            <tag> rvalue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>copy_and_deepcopy</title>
      <link href="/2018/12/22/copy-and-deepcopy/"/>
      <url>/2018/12/22/copy-and-deepcopy/</url>
      
        <content type="html"><![CDATA[<h2 id="copy-and-deepcopy"><a href="#copy-and-deepcopy" class="headerlink" title="copy and deepcopy"></a>copy and deepcopy</h2><p>在python3 中 复制分为三种,即 “赋值” “浅拷贝” “深拷贝”.python 官方文档解释如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assignment statements in Python do not copy objects, they create bindings between a target and an object. For collections that are mutable or contain mutable items, a copy is sometimes needed so one can change one copy without changing the other. This module provides generic shallow and deep copy operations (explained below).</span><br></pre></td></tr></table></figure><hr><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>赋值即利用 “=” 号运算符进行赋值, 但是这种赋值其本质是 “引用”, 即 重新创建一个变量名,然后绑定到 “=” 号右值的地址,这种情况下,<strong>任何对新创建的变量进行的修改都会同步到旧的变量上!</strong></p><p>案例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; old &#x3D; 2</span><br><span class="line">&gt;&gt;&gt; new &#x3D; old</span><br><span class="line">&gt;&gt;&gt; id(old)</span><br><span class="line">140721449431328</span><br><span class="line">&gt;&gt;&gt; id(new)</span><br><span class="line">140721449431328</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; old &#x3D; [1,2,3]</span><br><span class="line">&gt;&gt;&gt; new &#x3D; old</span><br><span class="line">&gt;&gt;&gt; old[0]&#x3D;&quot;1&quot;</span><br><span class="line">&gt;&gt;&gt; new</span><br><span class="line">[&#39;1&#39;, 2, 3]</span><br><span class="line">&gt;&gt;&gt; old is new</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; id(old)&#x3D;&#x3D;id(new)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>PS:总结来说,则是<strong>创建了一个新的变量名.然后指向旧变量的地址</strong></p><hr><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>第二种即是我们常说的 <strong>浅拷贝</strong> 这种拷贝是在于自定义的数据类型 被 “=” 运算符使用时所发生的.这种情况下 任何简易的修改(指 第一层引用的修改) 并不会改动另一个变量,但是在修改深处的值时,则依旧会影响到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; old &#x3D; [1,2,[3,4]]</span><br><span class="line">&gt;&gt;&gt; new &#x3D; copy.copy(old)</span><br><span class="line">&gt;&gt;&gt; old[0]&#x3D;&quot;1&quot;</span><br><span class="line">&gt;&gt;&gt; old</span><br><span class="line">[&#39;1&#39;, 2, [3, 4]]</span><br><span class="line">&gt;&gt;&gt; new</span><br><span class="line">[1, 2, [3, 4]]</span><br><span class="line">&gt;&gt;&gt; old[2][0] &#x3D; &quot;3&quot;</span><br><span class="line">&gt;&gt;&gt; old</span><br><span class="line">[&#39;1&#39;, 2, [&#39;3&#39;, 4]]</span><br><span class="line">&gt;&gt;&gt; new</span><br><span class="line">[1, 2, [&#39;3&#39;, 4]]</span><br></pre></td></tr></table></figure><p>PS:总结来说,<strong>浅拷贝在复制的时候,对于变量的第一层地址.创建了新的空间.但是对于第二层以下的地址.则是直接偷懒.把地址复制了赋予左边,并没有开创同等的空间</strong></p><hr><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>第三种 深拷贝 才是真正意义上的完全拷贝.即重新创建与右值同样大小的空间.然后循环复制.这种情况下.新创建的变量无论如何修改都不会影响到旧的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; old &#x3D; [1,2,[3,4]]</span><br><span class="line">&gt;&gt;&gt; new &#x3D; copy.deepcopy(old)</span><br><span class="line">&gt;&gt;&gt; new</span><br><span class="line">[1, 2, [3, 4]]</span><br><span class="line">&gt;&gt;&gt; new[0]&#x3D;&quot;1&quot;</span><br><span class="line">&gt;&gt;&gt; new[2][0]&#x3D;&quot;3&quot;</span><br><span class="line">&gt;&gt;&gt; new</span><br><span class="line">[&#39;1&#39;, 2, [&#39;3&#39;, 4]]</span><br><span class="line">&gt;&gt;&gt; old</span><br><span class="line">[1, 2, [3, 4]]</span><br></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><a href="https://docs.python.org/3/library/copy.html" target="_blank" rel="noopener">https://docs.python.org/3/library/copy.html</a></p><h5 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h5><pre><code>[ ] 加上图片</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python3 </tag>
            
            <tag> python </tag>
            
            <tag> copy </tag>
            
            <tag> deepcopy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpu 命名规则 intel篇</title>
      <link href="/2018/11/12/cpu-naming-rules-intel/"/>
      <url>/2018/11/12/cpu-naming-rules-intel/</url>
      
        <content type="html"><![CDATA[<p>intel cpu 型号众多，大概清理了一下命名规则</p><h2 id="intel-cpu-的产品系列"><a href="#intel-cpu-的产品系列" class="headerlink" title="intel cpu 的产品系列"></a>intel cpu 的产品系列</h2><hr><p>intel 分为 八个序列，分别为</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Core</span><span class="params">(酷睿)</span></span>：主要面向中高端消费者，工作站和发烧级的处理器系列,推出时取代了当时的Pentium(奔腾)处理器的中高端定位，并将Pentium移至入门级系列，也将Celeron(赛扬)处理器推向低端系列。Xeon(至强)处理器用于服务器和工作站市场,但早期命名规则混乱，严格来说不算是连续性的品牌。</span><br><span class="line"> </span><br><span class="line">Pentium：intel 早期推出的唯一处理器序列，后来衍生出低端的 Celeron 和 面向服务器的 Xeon 系列后，intel 又推出了 Core 系列取代 Pentium 系列后，彻底成为了低端处理器序列，市场定位在 Celeron 之上，Core 之下。</span><br><span class="line"></span><br><span class="line">Celeron: 早期由 Pentium 系列衍生出的低端型号~，在 Pentium 被 Core 取代后，市场定位更低了，彻底成为低端型号P</span><br><span class="line"></span><br><span class="line">Xeon：早期由 Pentium 系列衍生出来，主要供服务器及工作站使用，亦有超级计算机采用此处理器，历史悠久~。</span><br><span class="line"></span><br><span class="line">Xeon Phi(至强融核)：首款英特尔集成众核（Many Integrated Core，MIC）架构产品。用作高性能计算（HPC）的超级计算机或服务器的加速卡。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Itanium</span><span class="params">(安腾)</span></span>：是英特尔安腾架构（通常称之为IA-<span class="number">64</span>）的<span class="number">64</span>位处理器，市面上出现较少，近年来也没有消息。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Atom</span><span class="params">(凌动)</span></span>：Intel的一个超低电压处理器系列，和 Itanium 一样，近年比较少见。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Quark</span><span class="params">(夸克)</span></span>：Intel 最近新出的面向物联网的处理器序列，特点是小尺寸和低功耗。</span><br></pre></td></tr></table></figure><p>不过这里因为 Xeon Phi,Itanium,Atom,Quark 过于少见,就以常见的Core 和 Xeon 的命名规则作为讲解。</p><hr><h3 id="Core-命名规则"><a href="#Core-命名规则" class="headerlink" title="Core 命名规则"></a>Core 命名规则</h3><p>举一个例子，一个intel 完整的名称是：</p><center>Intel Core i7 - 7500 U</center><p>分开解析,Core 是品牌， i7 是标识符，标明其在品牌中的定位，7 代表着代数，是第七代处理器，500是 <strong>S</strong> tock <strong>K</strong> eeping <strong>U</strong> nit,类似于图书的ISBN号，用于内部标识，但是根据实际情况，数值越大，性能越强。<br>U 代表着后缀，类似于修饰符的功能，一般有K(可超频)，T(功耗优化)，M(移动处理器)等。</p><p>在一般看到一款CPU型号的时候，一般来说在 标识符(i3,i5,i7)和代数(5th,6th,7th)相同的情况下，SKU越大，性能越强，对于性能比较来说，通常是 标识符&gt;代数&gt;SKU。</p><hr><h3 id="Xeon-命名规则"><a href="#Xeon-命名规则" class="headerlink" title="Xeon 命名规则"></a>Xeon 命名规则</h3><p>Xeon 系列 比较复杂，下面由两个分支，这里先拿标准的至强处理器当作案例</p><center> Intel Xeon E3 - 1230 V3 </center><p>和之前一样，Intel Xeon 是品牌，E3 是生产线区别 ，也是标识符，1 指的是单主板下最大CPU数量，2 指的是 接口类型，30 指的是 SKU ，通常在SKU后面会有一些修饰符，例如 E3-1230L V3 这种，L表示的就是低功耗的修饰符，V3 则代表了这是这款CPU型号的第三代。</p><p>近年新出的 至强可扩展处理器，下面是一个经典的案例：</p><center> Intel Xeon Pltinum 8180 m processor</center><p>一样，Intel Xeon 是品牌，Platium 是其型号定位，8 是 SKU level ,表示性能和级别，可以理解型号定位的细化版本，1 是处理器的代数 80 是SKU，SKU后面有可能会有一到两个修饰符。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://ark.intel.com/content/www/cn/zh/ark.html#@Processors" target="_blank" rel="noopener">https://ark.intel.com/content/www/cn/zh/ark.html#@Processors</a></p><hr><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input disabled="" type="checkbox"> 加入时间序列</li><li><input disabled="" type="checkbox"> 撰写 amd 篇</li><li><input disabled="" type="checkbox"> 加上图片</li><li><input disabled="" type="checkbox"> 补充其他序列</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> cpu </tag>
            
            <tag> 命名规则 </tag>
            
            <tag> intel </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
