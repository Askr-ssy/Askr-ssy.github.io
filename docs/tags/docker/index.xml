<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>docker - Tag - sunflower</title>
        <link>https://blog.askr.cc/tags/docker/</link>
        <description>docker - Tag - sunflower</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 03 Apr 2020 17:38:13 &#43;0000</lastBuildDate><atom:link href="https://blog.askr.cc/tags/docker/" rel="self" type="application/rss+xml" /><item>
    <title>[翻译]Docker镜像:第一部分-减少镜像大小</title>
    <link>https://blog.askr.cc/posts/docker-images-part1-reducing-image-size/</link>
    <pubDate>Fri, 03 Apr 2020 17:38:13 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://blog.askr.cc/posts/docker-images-part1-reducing-image-size/</guid>
    <description><![CDATA[该文为翻译文章,因文章写的太好,见猎心喜,未拿到原作者授权,侵删.
原文链接
以下为正文
介绍 在刚开始使用容器的时候,很容易被我们所生成的镜像大小震惊.我们将回顾许多在不缩减开发人员和维护人员的便捷性的情况下,同时缩减镜像尺寸的技术.在第一部分中,我们将讨论多阶段构建,因为任何想要缩减镜像大小的人都需要从这开始.我们还将说明静态链接和动态链接之间的区别,以及为什么我们要关心它.同时,这也是介绍Alpine1的机会.
在第二部分,我们将看到与各种流行语言有关的一些特殊性.我们将讨论 GO,以及Java,Node,Python,Ruby,Rust.我们还将讨论有关Alpine的更多信息,以及如何全面利用Alpine.
在第三部分中,我们将介绍一些与大多数语言和框架相关的 Pattern ( and anti-patterns! ),例如使用通用基础镜像,分离二进制文件并减小大小.我们将总结一些更奇特的或高级的方法,例如 Bazel,Distroless,DockerSlim或UPX . 我们将看到其中的一些方法在某些情况下会适得其反,但在某些特定情况下可能会有用.
请注意,示例代码以及此处提到的所有Dockerfile,都可以在公共GitHub存储库中方便地获得,并带有一个Compose文件来构建所有镜像并轻松比较它们的大小.
我们正在尝试解决的问题 我敢打赌,每个构建了第一个Docker镜像并编译了一些代码的人都对该镜像的大小感到惊讶.
看看用C编写的这个繁琐的 &ldquo;hello world&rdquo; 程序：
/* hello.c */ int main () { puts(&#34;Hello, world!&#34;); return 0; } 我们可以使用下面这个Dockerfile构建它：
FROM gcc COPY hello.c . RUN gcc -o hello hello.c CMD [&#34;./hello&#34;] 但是生成的镜像将超过1 GB,因为它包含着整个gcc镜像！
如果我们使用Ubuntu镜像,安装一个C编译器,然后编译程序,我们将得到300 MB镜像；看起来更棒,但对于本身小于20 kB的二进制文件而言,仍然太多了：
$ ls -l hello -rwxr-xr-x 1 root root 16384 Nov 18 14:36 hello 一个同等效果的Go程序：
package main import &#34;fmt&#34; func main () { fmt.]]></description>
</item>
</channel>
</rss>
