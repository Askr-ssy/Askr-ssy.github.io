<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>import - Tag - sunflower</title>
        <link>https://blog.askr.cc/tags/import/</link>
        <description>import - Tag - sunflower</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 31 Mar 2019 14:45:42 &#43;0000</lastBuildDate><atom:link href="https://blog.askr.cc/tags/import/" rel="self" type="application/rss+xml" /><item>
    <title>python3_import</title>
    <link>https://blog.askr.cc/posts/python3-import/</link>
    <pubDate>Sun, 31 Mar 2019 14:45:42 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://blog.askr.cc/posts/python3-import/</guid>
    <description><![CDATA[Python3 Import 之 finder 在Python 中,导入一个模块最常见的方式就是使用 import 语句, import 语句本质是对 __import__ 语句的重写,不过这里并不多说, import 实际上分为两个过程,第一部分是搜索指定名称的模块,然后返回一个说明对象,另一个部分是根据前者返回的说明对象进行加载,这里我们首先说第一部分.
sys.modules 首先,Python 会对sys.modules 进行搜索, modules 这里起到了缓存之前导入的所有模块的作用. 如果在搜索 sys.modules 中找模块名称关联的值,那么说明其不是第一次导入,其关联的值就是需要导入的模块,导入过程完成.
这里有需要注意的几点
sys.modules是可写的 删除key 并不会破坏关联的模块(因为其他模块可能会保留对它的引用),但会使模块名的缓存目录失效,导致下次导入时,重新搜索. 如果 sys.modules 中存在指定的名称，但是关联值却为 none 那么会引发 ModuleNotFoundError。 如果指定名称的模块在 sys.modules 找不到，则将发起调用 Python 的导入协议以查找和加载该模块. 此协议由两个概念性模块构成，即 查找器 和 加载器 .查找器的任务是确定是否能使用其所知的策略找到该名称的模块。 同时实现这两种接口的对象称为 导入器 它们在确定能加载所需的模块时会返回其自身。
sys.meta_path Python默认包含三个导入器, 第一个知道如何定位内置模块，第二个知道如何定位冻结模块。 第三个默认查找器会在 导入路径中(一般为sys.path) 中搜索模块。 导入路径 是一个由文件系统路径或 zip 文件组成的位置列表。 它还可以扩展为搜索任意可定位资源，例如由 URL 指定的资源。
PS: 可以在sys.meta_path 看到默认包含的三个导入器
PS:导入机制是可扩展的，因此可以加入新的查找器以扩展模块搜索的范围和作用域
find_spec() Python 中,如果你在sys.modules中无法找到模块,那么会搜索sys.meta_path ,其中包含 元路径查找器 对象列表,查找器必须实现 find_spec() 这一方法，该方法接受三个参数：名称、导入路径和目标模块（可选，元路径查找器可使用任何策略来确定它是否能处理指定名称的模块。]]></description>
</item>
</channel>
</rss>
